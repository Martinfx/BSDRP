Index: tools/tools/netrate/netreceive/Makefile
===================================================================
--- tools/tools/netrate/netreceive/Makefile	(revision 338607)
+++ tools/tools/netrate/netreceive/Makefile	(working copy)
@@ -5,6 +5,7 @@
 PROG=	netreceive
 MAN=
 LDFLAGS += -lpthread
+BINDIR=	/usr/local/bin
 
 WARNS?=	3
 
Index: tools/tools/netrate/netreceive/netreceive.c
===================================================================
--- tools/tools/netrate/netreceive/netreceive.c	(revision 338607)
+++ tools/tools/netrate/netreceive/netreceive.c	(working copy)
@@ -60,8 +60,8 @@
 	pthread_t td_id;
 	uint64_t count;	/* rx counter */
 	uint64_t byte_count;	/* rx byte counter */
-	int fd;
 	char *buf;
+	char *argv;
 	int buflen;
 };
 
@@ -101,19 +101,71 @@
 rx_body(void *data)
 {
 	struct td_desc *t = data;
+	struct addrinfo hints = {0}, *res = NULL , *res0 = NULL;
 	struct pollfd fds;
-	int y;
+	int error, y;
+	const char *cause = NULL;
 
-	fds.fd = t->fd;
+	hints.ai_family = PF_UNSPEC;
+	hints.ai_socktype = SOCK_DGRAM;
+	hints.ai_flags = AI_PASSIVE;
+
+    int v = 1; /* dummy value for setsockopt */
+	error = getaddrinfo(NULL, t->argv, &hints, &res0);
+	if (error) {
+		perror(gai_strerror(error));
+		return NULL;
+		/*NOTREACHED*/
+	}
+
+	int s = -1; /* socket */
+	for (res = res0; res ; res = res->ai_next) {
+		s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+		if (s < 0) {
+			cause = "socket";
+			continue;
+		}
+
+#if __FreeBSD_version <= 1200069
+		if (setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &v, sizeof v) < 0) {
+			cause = "SO_REUSEPORT";
+#else
+		if (setsockopt(s, SOL_SOCKET, SO_REUSEPORT_LB, &v, sizeof v) < 0) {
+            cause = "SO_REUSEPORT_LB";
+#endif
+			close(s);
+			continue;
+		}
+
+		v = 128 * 1024;
+		if (setsockopt(s, SOL_SOCKET, SO_RCVBUF, &v, sizeof(v)) < 0) {
+			cause = "SO_RCVBUF";
+			close(s);
+			continue;
+		}
+		if (bind(s, res->ai_addr, res->ai_addrlen) < 0) {
+			cause = "bind";
+			close(s);
+			continue;
+		}
+		(void) listen(s, 5);
+	}
+	if (s < 0) {
+		perror(cause);
+		return NULL;
+		/*NOTREACHED*/
+	}
+
+	fds.fd = s;
 	fds.events = POLLIN;
 
 	for (;;) {
-		if (poll(&fds, 1, -1) < 0) 
+		if (poll(&fds, 1, -1) < 0)
 			perror("poll on thread");
 		if (!(fds.revents & POLLIN))
 			continue;
 		for (;;) {
-			y = recv(t->fd, t->buf, t->buflen, MSG_DONTWAIT);
+			y = recv(s, t->buf, t->buflen, MSG_DONTWAIT);
 			if (y < 0)
 				break;
 			t->count++;
@@ -124,12 +176,11 @@
 }
 
 static struct td_desc **
-make_threads(int *s, int nsock, int nthreads)
+make_threads(char *argv, int nthreads)
 {
-	int i, si, nt = nsock * nthreads;
-	int lb = round_to(nt * sizeof (struct td_desc *), 64);
+	int lb = round_to(nthreads * sizeof (struct td_desc *), 64);
 	int td_len = round_to(sizeof(struct td_desc), 64); // cache align
-	char *m = calloc(1, lb + td_len * nt);
+	char *m = calloc(1, lb + td_len * nthreads);
 	struct td_desc **tp;
 
 	printf("td len %d -> %d\n", (int)sizeof(struct td_desc) , td_len);
@@ -140,13 +191,11 @@
 	}
 	tp = (struct td_desc **)m;
 	m += lb;	/* skip the pointers */
-	for (si = i = 0; i < nt; i++, m += td_len) {
+	for (int i = 0; i < nthreads; i++, m += td_len) {
 		tp[i] = (struct td_desc *)m;
-		tp[i]->fd = s[si];
+		tp[i]->argv = argv;
 		tp[i]->buflen = 65536;
 		tp[i]->buf = calloc(1, tp[i]->buflen);
-		if (++si == nsock)
-			si = 0;
 		if (pthread_create(&tp[i]->td_id, NULL, rx_body, tp[i])) {
 			perror("unable to create thread");
 			exit(1);
@@ -156,26 +205,29 @@
 }
 
 static void
-main_thread(struct td_desc **tp, int nsock, int nthreads)
+main_thread(struct td_desc **tp, int nthreads)
 {
 	uint64_t c0, c1, bc0, bc1;
 	struct timespec now, then, delta;
 	/* now the parent collects and prints results */
 	c0 = c1 = bc0 = bc1 = 0;
+	uint64_t old[128] = {0};
 	clock_gettime(CLOCK_REALTIME, &then);
-	fprintf(stderr, "start at %ld.%09ld\n", then.tv_sec, then.tv_nsec);
+	fprintf(stderr, "start at %jd.%09ld\n", (__intmax_t)then.tv_sec, then.tv_nsec);
 	while (1) {
-		int i, nt = nsock * nthreads;
 		int64_t dn;
 		uint64_t pps, bps;
 
-		if (poll(NULL, 0, 500) < 0) 
+		if (poll(NULL, 0, 500) < 0)
 			perror("poll");
 		c0 = bc0 = 0;
-		for (i = 0; i < nt; i++) {
+		for (int i = 0; i < nthreads; i++) {
 			c0 += tp[i]->count;
 			bc0 += tp[i]->byte_count;
+			/* printf("thread %d: recv %lu ", i, tp[i]->count - old[i]); */
+			old[i] = tp[i]->count;
 		}
+		/* printf("\n"); */
 		dn = c0 - c1;
 		clock_gettime(CLOCK_REALTIME, &now);
 		delta = now;
@@ -185,8 +237,8 @@
 		pps = (pps * 1000000000) / (delta.tv_sec*1000000000 + delta.tv_nsec + 1);
 		bps = ((bc0 - bc1) * 8000000000) / (delta.tv_sec*1000000000 + delta.tv_nsec + 1);
 		fprintf(stderr, " %9ld pps %8.3f Mbps", (long)pps, .000001*bps);
-		fprintf(stderr, " - %d pkts in %ld.%09ld ns\n",
-			(int)dn, delta.tv_sec, delta.tv_nsec);
+		fprintf(stderr, " - %d pkts in %jd.%09ld ns\n",
+			(int)dn, (__intmax_t)delta.tv_sec, delta.tv_nsec);
 		c1 = c0;
 		bc1 = bc0;
 	}
@@ -195,23 +247,14 @@
 int
 main(int argc, char *argv[])
 {
-	struct addrinfo hints, *res, *res0;
 	char *dummy, *packet;
 	int port;
-	int error, v, nthreads = 1;
+	int nthreads = 1;
 	struct td_desc **tp;
-	const char *cause = NULL;
-	int s[MAXSOCK];
-	int nsock;
 
 	if (argc < 2)
 		usage();
 
-	memset(&hints, 0, sizeof(hints));
-	hints.ai_family = PF_UNSPEC;
-	hints.ai_socktype = SOCK_DGRAM;
-	hints.ai_flags = AI_PASSIVE;
-
 	port = strtoul(argv[1], &dummy, 10);
 	if (port < 1 || port > 65535 || *dummy != '\0')
 		usage();
@@ -227,48 +270,9 @@
 	}
 	bzero(packet, 65536);
 
-	error = getaddrinfo(NULL, argv[1], &hints, &res0);
-	if (error) {
-		perror(gai_strerror(error));
-		return (-1);
-		/*NOTREACHED*/
-	}
+	printf("netreceive using %d threads listening on UDP port %d\n",
+		nthreads, (u_short)port);
 
-	nsock = 0;
-	for (res = res0; res && nsock < MAXSOCK; res = res->ai_next) {
-		s[nsock] = socket(res->ai_family, res->ai_socktype,
-		res->ai_protocol);
-		if (s[nsock] < 0) {
-			cause = "socket";
-			continue;
-		}
-
-		v = 128 * 1024;
-		if (setsockopt(s[nsock], SOL_SOCKET, SO_RCVBUF, &v, sizeof(v)) < 0) {
-			cause = "SO_RCVBUF";
-			close(s[nsock]);
-			continue;
-		}
-		if (bind(s[nsock], res->ai_addr, res->ai_addrlen) < 0) {
-			cause = "bind";
-			close(s[nsock]);
-			continue;
-		}
-		(void) listen(s[nsock], 5);
-		nsock++;
-	}
-	if (nsock == 0) {
-		perror(cause);
-		return (-1);
-		/*NOTREACHED*/
-	}
-
-	printf("netreceive %d sockets x %d threads listening on UDP port %d\n",
-		nsock, nthreads, (u_short)port);
-
-	tp = make_threads(s, nsock, nthreads);
-	main_thread(tp, nsock, nthreads);
-
-	/*NOTREACHED*/
-	freeaddrinfo(res0);
+	tp = make_threads(argv[1], nthreads);
+	main_thread(tp, nthreads);
 }
