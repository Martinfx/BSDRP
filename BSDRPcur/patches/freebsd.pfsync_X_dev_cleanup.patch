commit 360aefdee3a80809c86a59793a1e7de1eedd44e2
Author: Kristof Provost <kristof@codepro.be>
Date:   Mon Sep 3 22:38:05 2018 +0200

    pfsync: Handle syncdev going away
    
    If the syncdev is removed we no longer need to clean up the multicast
    entry we've got set up for that device.
    
    Pass the ifnet detach event through pf to pfsync, and remove our
    multicast handle, and mark us as no longer having a syncdev.

diff --git sys/net/pfvar.h sys/net/pfvar.h
index 769863d6522..ea7ec8936cf 100644
--- sys/net/pfvar.h
+++ sys/net/pfvar.h
@@ -824,6 +824,7 @@ typedef	int		pfsync_update_state_t(struct pf_state *);
 typedef	void		pfsync_delete_state_t(struct pf_state *);
 typedef void		pfsync_clear_states_t(u_int32_t, const char *);
 typedef int		pfsync_defer_t(struct pf_state *, struct mbuf *);
+typedef void		pfsync_detach_ifnet_t(struct ifnet *);
 
 VNET_DECLARE(pfsync_state_import_t *, pfsync_state_import_ptr);
 #define V_pfsync_state_import_ptr	VNET(pfsync_state_import_ptr)
@@ -837,6 +838,8 @@ VNET_DECLARE(pfsync_clear_states_t *, pfsync_clear_states_ptr);
 #define V_pfsync_clear_states_ptr	VNET(pfsync_clear_states_ptr)
 VNET_DECLARE(pfsync_defer_t *, pfsync_defer_ptr);
 #define V_pfsync_defer_ptr		VNET(pfsync_defer_ptr)
+VNET_DECLARE(pfsync_detach_ifnet_t *, pfsync_detach_ifnet_ptr);
+#define V_pfsync_detach_ifnet_ptr	VNET(pfsync_detach_ifnet_ptr)
 
 void			pfsync_state_export(struct pfsync_state *,
 			    struct pf_state *);
diff --git sys/netpfil/pf/if_pfsync.c sys/netpfil/pf/if_pfsync.c
index 4b06e123e71..a7e62956ab6 100644
--- sys/netpfil/pf/if_pfsync.c
+++ sys/netpfil/pf/if_pfsync.c
@@ -333,6 +333,7 @@ static void	pfsync_bulk_fail(void *);
 static void	pfsync_delete_state_now(struct pfsync_softc *,
 		    struct pf_state *st);
 
+static void	pfsync_detach_ifnet(struct ifnet *);
 #ifdef IPSEC
 static void	pfsync_update_net_tdb(struct pfsync_tdb *);
 #endif
@@ -2555,6 +2556,25 @@ pfsync_multicast_cleanup(struct pfsync_softc *sc)
 	imo->imo_multicast_ifp = NULL;
 }
 
+void
+pfsync_detach_ifnet(struct ifnet *ifp)
+{
+	struct pfsync_softc *sc = V_pfsyncif;
+
+	PFSYNC_LOCK(sc);
+
+	if (sc->sc_sync_if == ifp) {
+		/* We don't need mutlicast cleanup here, because the interface
+		 * is going away. We do need to ensure we don't try to do
+		 * cleanup later. */
+		sc->sc_imo.imo_membership = NULL;
+		sc->sc_imo.imo_multicast_ifp = NULL;
+		sc->sc_sync_if = NULL;
+	}
+
+	PFSYNC_UNLOCK(sc);
+}
+
 #ifdef INET
 extern  struct domain inetdomain;
 static struct protosw in_pfsync_protosw = {
@@ -2580,6 +2600,7 @@ pfsync_pointers_init()
 	V_pfsync_delete_state_ptr = pfsync_delete_state;
 	V_pfsync_clear_states_ptr = pfsync_clear_states;
 	V_pfsync_defer_ptr = pfsync_defer;
+	V_pfsync_detach_ifnet_ptr = pfsync_detach_ifnet;
 	PF_RULES_WUNLOCK();
 }
 
@@ -2594,6 +2615,7 @@ pfsync_pointers_uninit()
 	V_pfsync_delete_state_ptr = NULL;
 	V_pfsync_clear_states_ptr = NULL;
 	V_pfsync_defer_ptr = NULL;
+	V_pfsync_detach_ifnet_ptr = NULL;
 	PF_RULES_WUNLOCK();
 }
 
diff --git sys/netpfil/pf/pf_if.c sys/netpfil/pf/pf_if.c
index 4e6bae4dd00..816f897165c 100644
--- sys/netpfil/pf/pf_if.c
+++ sys/netpfil/pf/pf_if.c
@@ -829,6 +829,9 @@ pfi_detach_ifnet_event(void *arg __unused, struct ifnet *ifp)
 {
 	struct pfi_kif *kif = (struct pfi_kif *)ifp->if_pf_kif;
 
+	if (V_pfsync_detach_ifnet_ptr)
+		V_pfsync_detach_ifnet_ptr(ifp);
+
 	if (kif == NULL)
 		return;
 
diff --git sys/netpfil/pf/pf_ioctl.c sys/netpfil/pf/pf_ioctl.c
index 56e6bc0d97f..83b8a3f2457 100644
--- sys/netpfil/pf/pf_ioctl.c
+++ sys/netpfil/pf/pf_ioctl.c
@@ -218,6 +218,7 @@ VNET_DEFINE(pfsync_update_state_t *, pfsync_update_state_ptr);
 VNET_DEFINE(pfsync_delete_state_t *, pfsync_delete_state_ptr);
 VNET_DEFINE(pfsync_clear_states_t *, pfsync_clear_states_ptr);
 VNET_DEFINE(pfsync_defer_t *, pfsync_defer_ptr);
+VNET_DEFINE(pfsync_detach_ifnet_t *, pfsync_detach_ifnet_ptr);
 
 /* pflog */
 pflog_packet_t			*pflog_packet_ptr = NULL;
